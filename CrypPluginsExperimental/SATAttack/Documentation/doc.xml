<?xml version="1.0" encoding="utf-8"?>
<!-- You can edit this file manually or with the Util/CrypDocumentationEditor -->
<documentation>
  <language culture="en" />
  <language culture="zh-CN" />
  <language culture="ru" />
  <language culture="de-DE" />
  <introduction lang="en">
    The SAT problem (abbreviation for <i>Boolean <b>sat</b>isfiability problem</i>) deals with the question whether a Boolean formula is satisfiable. Algorithms named SAT solver are able to solve this problem even for very large formulas. For detailed information about SAT solvers and the SAT problem, you can read the help file of the <docRef item="CrypTool.Plugins.SATSolver.SATSolver" /> component.<newline /><newline />
    SAT solvers have been used as tools in cryptanalysis since 1999. Any cryptographic function can be encoded in a Boolean formula in conjunctive normal form (CNF), which is the common input format for a SAT solver. Further information for the encoding of the specific properties of an attack must be added to the CNF: Consider for instance a preimage attack on a hash function. In this case, the encoding of the bits of the hash value are added to the CNF. When the SAT solver is able to solve the resulting CNF, the variable assignment obtained from the SAT solver output contains information about a valid preimage (a message that hashes to the provided hash value).<newline /><newline />
    The encoding of a cryptographic function in CNF is a laborious task. Usually the complete function is first written in another format (algebraic normal form, ANF) and then transformed into CNF. The advantage of this intermediate step is that it is comparably simple to write a cryptographic function in ANF instead of directly encoding the function in CNF. The transformation from ANF to CNF does not require any further effort as the transformation is generic and can be performed automatically. The tool XL0 for instance which can be found at <ref id="xl0" /> provides the functionality to transform ANF equations into CNF.<newline /><newline />
    The benefit of the SAT Attack component is that the encoding in CNF is performed automatically. The component uses a modified version of the bounded model checker tool CBMC to transform the ANSI-C code of a cryptographic function into a Boolean circuit which is then transformed into CNF. The type of attack and the required parameters (e.g. the hash value for a preimage attack on a hash function) must be entered in the component's settings. The encoding of this information is added to the CNF before the SAT solver tries to solve the CNF. Finally the SAT Attack component outputs a solution to the attack or prints out status information if the attack failed. Notice that both the SAT solver and CBMC are called by the SAT Attack component as external processes.<newline /><newline /><!-- TODO: Verweis auf template -->
    Please notice, SAT-based cryptanalysis with the SAT Attack component is not as successful as in the case when the CNF encoding is performed manually. This is due to the fact that the automatic transformation from ANSI-C code leads to a CNF which is not as optimized as manually performed encoding. However, the component provides a timely and easy-to-use approach for SAT-based cryptanalysis. Therefore, the component is especially useful for the first analysis of new cryptographic functions to get an idea of their vulnerability or resilience against algebraic attacks.
  </introduction>
  <introduction lang="zh-CN">SAT问题（布尔可满足性问题的缩写）处理布尔表达式是否可满足的问题。甚至对于很大的公式，名为SAT求解器的算法也能够解决此问题。有关SAT解算器和SAT问题的详细信息，您可以阅读组件的帮助文件。自1999年以来，SAT求解器就已用作加密分析的工具。任何加密函数都可以以布尔合规范式（CNF）的布尔公式进行编码，这是SAT求解器的常见输入格式。必须将攻击的特定属性编码的更多信息添加到CNF：例如，考虑对散列函数的前映像攻击。在这种情况下，哈希值的比特的编码被添加到CNF。当SAT求解器能够求解结果CNF时，从SAT求解器输出获得的变量分配包含有关有效原像（散列为提供的哈希值的消息）的信息。 CNF中密码功能的编码是一项艰巨的任务。通常，完整功能首先以另一种格式（代数范式，ANF）编写，然后转换为CNF。该中间步骤的优点是，相比于在CNF中直接编码该函数，以ANF编写一个加密函数相对简单。从ANF到CNF的转换不需要任何额外的工作，因为该转换是通用的并且可以自动执行。例如，可以在以下位置找到的工具XL0提供了将ANF方程转换为CNF的功能。 SAT Attack组件的好处是CNF中的编码是自动执行的。该组件使用有界模型检查器工具CBMC的修改版本将密码函数的ANSI-C代码转换为布尔电路，然后将该布尔电路转换为CNF。必须在组件的设置中输入攻击的类型和所需的参数（例如，对哈希函数进行前映像攻击的哈希值）。在SAT求解器尝试求解CNF之前，将此信息的编码添加到CNF。最终，SAT Attack组件会输出针对该攻击的解决方案，或者在攻击失败时打印出状态信息。注意，SAT Attack组件将SAT求解器和CBMC都称为外部进程。请注意，带有SAT Attack组件的基于SAT的密码分析不如手动执行CNF编码时那样成功。这是由于以下事实：从ANSI-C代码的自动转换导致CNF的优化程度不如手动执行的编码。但是，该组件为基于SAT的密码分析提供了一种及时且易于使用的方法。因此，该组件对于首先分析新的密码功能以了解其对代数攻击的脆弱性或弹性特别有用。</introduction>
  <introduction lang="ru">Проблема SAT (аббревиатура для задачи логической выполнимости) имеет дело с вопросом, является ли булева формула выполнимой. Алгоритмы с именем SAT solver способны решить эту проблему даже для очень больших формул. Подробную информацию о решателях SAT и проблеме SAT вы можете прочитать файл справки компонента. Решатели SAT использовались в качестве инструментов криптоанализа с 1999 года. Любая криптографическая функция может быть закодирована в булевой формуле в конъюнктивной нормальной форме (CNF), которая является общим форматом ввода для SAT-решателя. Дополнительная информация для кодирования конкретных свойств атаки должна быть добавлена ​​в CNF: Рассмотрим, например, атаку проема на хэш-функцию. В этом случае кодирование битов хэш-значения добавляется в CNF. Когда SAT-решатель способен решить возникающую CNF, назначение переменной, полученное из выходного файла SAT, содержит информацию о действительном прообразе (сообщение, которое хеширует предоставленное значение хэш-функции). Кодирование криптографической функции в CNF является трудоемкой задачей. Обычно полная функция сначала записывается в другом формате (алгебраическая нормальная форма, ANF), а затем преобразуется в CNF. Преимущество этого промежуточного шага заключается в том, что сравнительно просто написать криптографическую функцию в ANF вместо прямого кодирования функции в CNF. Преобразование из ANF в CNF не требует каких-либо дополнительных усилий, поскольку преобразование является общим и может выполняться автоматически. Например, инструмент XL0, который можно найти, обеспечивает функциональность преобразования ANF-уравнений в CNF. Преимущество компонента SAT Attack заключается в том, что кодирование в CNF выполняется автоматически. Компонент использует модифицированную версию средства проверки ограниченной модели CBMC для преобразования кода ANSI-C криптографической функции в логическую схему, которая затем преобразуется в CNF. Тип атаки и требуемые параметры (например, хеш-значение для атаки preimage для хэш-функции) должны быть введены в настройках компонента. Кодирование этой информации добавляется в CNF до того, как решатель SAT попытается решить CNF. Наконец, компонент SAT Attack выводит решение для атаки или выводит информацию о состоянии, если атака не удалась. Обратите внимание, что как SAT-решатель, так и CBMC вызываются компонентом SAT Attack как внешние процессы. Обратите внимание, что криптоанализ на основе SAT с компонентом SAT Attack не так успешен, как в случае, когда CNF-кодирование выполняется вручную. Это связано с тем, что автоматическое преобразование из кода ANSI-C приводит к CNF, который не так оптимизирован, как ручное кодирование. Однако компонент обеспечивает своевременный и простой в использовании подход для криптоанализа на основе SAT. Поэтому компонент особенно полезен для первого анализа новых криптографических функций, чтобы получить представление об их уязвимости или устойчивости к алгебраическим атакам.</introduction>
  <introduction lang="de-DE">
    Das SAT-Problem (von engl. <i>Boolean <b>sat</b>isfiability problem</i>, <i>Erfüllbarkeitsproblem der Aussagenlogik</i>) fragt nach der Erfüllbarkeit einer aussagenlogischen Formel. Sogenannte SAT-Solver sind Algorithmen, die das SAT-Problem selbst für sehr große Formeln lösen können. Ausführliche Informationen über SAT-Solver und über das SAT-Problem finden Sie in der Hilfe-Datei der <docRef item="CrypTool.Plugins.SATSolver.SATSolver" />-Komponente.<newline /><newline />
    SAT-Solver wurden 1999 zum ersten Mal als Werkzeug in der Kryptoanalyse eingesetzt. Grundsätzlich kann jede kryptografische Funktion als eine aussagenlogische Formel kodiert werden. Üblicherweise wird die Formel in die konjunktive Normalform (CNF von engl. conjunctive normal form) gebracht, da dies das gängige Eingabeformat von SAT-Solvern ist. Weitere Informationen, die die speziellen Eigenschaften des gewählten Angriffstyps kodieren, müssen der CNF hinzugefügt werden: Bei einem Pre-Image-Angriff auf eine Hashfunktion beispielsweise wird die Kodierung der Bits des Hashwertes der CNF hinzugefügt. Wenn der SAT-Solver eine Lösung für die CNF findet, kann man von der Variablenbelegung, die der SAT-Solver ausgibt, auf ein gültiges Pre-Image (eine Nachricht, deren Hash den angegebenen Hashwert ergibt) schließen.<newline /><newline />
    Das Kodieren einer kryptografischen Funktion in CNF ist sehr arbeitsaufwändig. Üblicherweise schreibt man zuerst die gesamte Funktion in einem anderen Format (algebraische Normalform, ANF) und transformiert diese dann nach CNF. Der Vorteil dieses Zwischenschrittes ist, dass es vergleichsweise einfach ist, eine kryptografische Funktion mit ANF-Gleichungen darzustellen anstatt direkt nach CNF zu kodieren. Die Transformation von ANF nach CNF braucht keinen weiteren Aufwand, da die Transformation generisch ist und daher automatisiert werden kann. Das Tool XL0 beispielsweise, welches bei <ref id="xl0" /> gefunden werden kann, ermöglicht die Transformation von ANF-Gleichungen nach CNF.<newline /><newline />
    Der Vorteil der SAT-Attack-Komponente ist es, dass das Kodieren in die CNF automatisch geschieht. Die Komponente nutzt eine modifizierte Version des Bounded-Model-Checker-Tools CBMC, um aus dem ANSI-C-Code einer kryptografischen Funktion einen Bool'schen Schaltkreis zu generieren. Dieser Schaltkreis wird dann in eine CNF-Darstellung der Funktion transformiert. Die Art des Angriffs und die benötigten Parameter (z.B. der Hashwert für einem Pre-Image-Angriff auf eine Hashfunktion) können in den Einstellungen der Komponente angegeben werden. Die Kodierung dieser zusätzlichen Parameter wird der CNF hinzugefügt, bevor der SAT-Solver versucht, die CNF zu lösen. Schließlich gibt die SAT-Attack-Komponente im Erfolgsfall eine Lösung für den Angriff aus, oder Statusinformationen, falls der Angriff fehlschlug. Sowohl der SAT-Solver als auch das CBMC-Tool werden  von der SAT-Attack-Komponente als externe Prozesse aufgerufen werden. <newline /><newline /><!-- TODO: Verweis auf template --></introduction>
    Bitte beachten Sie, dass eine automatisierte SAT-basierte Kryptoanalyse, die mit der SAT-Attack-Komponente durchgeführt wird, nicht gleichermaßen erfolgreich ist, wie eine Analyse, bei der das Kodieren der CNF manuell durchgeführt wurde. Dies lässt sich damit begründen, dass eine manuelle Kodierung zu einer stärker optimierten CNF führt als bei der automatischen Transformation von ANSI-C-Code nach CNF. Nichtsdestotrotz bietet die SAT-Attack-Komponente eine leicht anwendbare Möglichkeit für die SAT-basierte Kryptoanalyse, die wenig zeitaufwändig ist. Daher ist die Komponente vor allem nützlich für erste Analysen von neuen kryptografischen Funktionen, um einen Eindruck von der Anfälligkeit oder der Widerstandsfähigkeit gegenüber algebraischen Angriffen zu bekommen.

  <usage lang="en"><section headline="Input and Output">
      The SAT Attack component has one input and three output connectors. Through the input connector, the ANSI-C code can be passed directly to the component when pasted in a connected Text Input component. However, the input connector is not mandatory since the ANSI-C code can also directly be passed to the component when the "File input" option is chosen in the settings (see the <i>Parameters</i> section below). The two output connectors "CBMC output stream" and "SAT solver output stream" each forward the output of the related process. As they only display status information of these two processes, the outputs are optional and the component will run even when they are not connected. The last output connector named "Output stream" is the only mandatory connector. It outputs status information about the progress of the component and, finally, the result of the attack if it could be found.
    </section><section headline="Parameters">
      The SAT Attack component allows the user to choose between several attack types and offers various settings which are explained in the following. Some parameters are entered via text boxes. The strings entered in these text boxes can either be hexadecimal strings denoted with the prefix "0x", or binary strings denoted with the prefix "0b".
      <list><item><b>Attack type</b> Choose between Preimage attack, Second preimage attack and Key-recovery attack.
        </item><item><b>Input selection</b> Choose whether the ANSI-C code is provided via a Text Input component which is connected with the input connector or directly via a file from a local storage device.
        </item><item><b>Main function name</b> Specify the name of the function which is the entry point in the ANSI-C code, if this is not the function named "main()".
        </item><item><b>Save CNF in file</b> Provides the option to save the generated CNF in a file on a local storage device.
        </item><item><b>CNF output only</b> Check this option, if the component should stop the execution after the CNF is generated and the chosen attack is encoded in the CNF. This will skip the solving by the SAT solver.
        </item><item><b>Fix input bits</b> Check this option for the possibility to fix (i.e. specify the value at specific bit locations) some of the input bits. When checked, a text box will appear below where the user can enter a binary or hexadecimal string to fix some of the input bits in advance. If a bit or a nibble in the string should not be fixed, this can be denoted with the character '*'. The string "0b0***1" for instance fixes the least significant bit to the value '1' and the most significant bit to the value '0'. The bits between these two bits are not fixed.
        </item></list>
      The following options are visible depending on the selected attack type.
      <list><item><b>Hash value</b> Provide the hash value for which the component tries to find a valid preimage (or second preimage).
        </item><item><b>Second preimage</b> Provide a valid second preimage which hashes to the provided hash value.
        </item><item><b>Plaintext</b> Provide a plaintext for a key-recovery attack.
        </item><item><b>Ciphertext</b> Provide a ciphertext for a key-recovery attack.
        </item></list>

      The solution which is output by the SAT Attack component is a valid preimage in case of a preimage or second preimage attack on a hash function, or the symmetric key in case of a key-recovery attack on a symmetric cipher. The ANSI-C code has to be modified since the input and output variables need to be known by the translation tool CBMC. Therefore, the input and output variables have to be tagged in a particular way: The input and output variables must be denoted "INPUT_x" and "OUTPUT_x" where the index 'x' is an incrementing number, starting with "INPUT_0" and "OUTPUT_0" for the least significant input or output variable. The ongoing numbers of the variables must be gapless and each of the variables must actually be used in the ANSI-C code.<newline /><newline />
      The variables must be assigned in the following way depending on the attack type:<newline /><newline /><b>Preimage and second preimage attack:</b><list><item><b>INPUT_0 - INPUT_n</b> Message (Preimage)
        </item><item><b>OUTPUT_0 - OUTPUT_k</b> Hash value
        </item></list><b>Key-recovery attack:</b><list><item><b>INPUT_0 - INPUT_n</b> Plaintext
        </item><item><b>INPUT_n+1 - INPUT_m</b> Key
        </item><item><b>OUTPUT_0 - OUTPUT_k</b> Ciphertext
        </item></list>
      In a key-recovery attack, it is important that the index of the least significant variable of the key starts right after the index of the most significant variable of the plaintext (if the most significant plaintext variable is "INPUT_63", the least significant key variables must be "INPUT_64"). If the variable notations are faulty, the component may output false solutions or return an error. It is also important that none of the input variables is assigned in the ANSI-C code and that all of the output variables are assigned. This means the input variables must always be on the right side of an assignment and the output variables must always be on the left side (e.g. OUTPUT_0 = INPUT_0 ^ INPUT_1).
    </section></usage><usage lang="zh-CN">SAT Attack组件具有一个输入和三个输出连接器。通过输入连接器，将ANSI-C代码粘贴到连接的文本输入组件中后，可以直接传递到该组件。但是，输入连接器不是必需的，因为当在设置中选择“文件输入”选项时，也可以将ANSI-C代码直接传递给组件（请参见下面的“参数”部分）。两个输出连接器“ CBMC输出流”和“ SAT求解器输出流”分别转发相关过程的输出。由于它们仅显示这两个进程的状态信息，因此输出是可选的，并且即使未连接组件也将运行。最后一个名为“输出流”的输出连接器是唯一的必需连接器。它输出有关组件进度的状态信息，如果可能，则输出有关攻击结果的信息。 SAT Attack组件允许用户在几种攻击类型之间进行选择，并提供各种设置，下面将对此进行说明。一些参数是通过文本框输入的。在这些文本框中输入的字符串可以是用前缀“ 0x”表示的十六进制字符串，也可以是用前缀“ 0b”表示的二进制字符串。攻击类型在“原像”攻击，“第二原像”攻击和“密钥恢复”攻击之间进行选择。输入选择选择是通过与输入连接器连接的文本输入组件还是直接通过本地存储设备中的文件提供ANSI-C代码。主函数名称如果不是名称为“ main（）”的函数，请指定函数名称，该函数是ANSI-C代码的入口。将CNF保存到文件中提供了将生成的CNF保存到本地存储设备上的文件中的选项。仅CNF输出如果生成CNF且组件在CNF中编码了选定的攻击之后组件是否应该停止执行，请选中此选项。这将跳过SAT求解器的求解。固定输入位选中此选项以修复某些输入位（即在特定位位置指定值）的可能性。选中后，将在下面显示一个文本框，用户可以在其中输入二进制或十六进制字符串以预先固定一些输入位。如果字符串中的位或半字节不固定，则可以用字符“ *”表示。例如，字符串“ 0b0 *** 1”将最低有效位固定为值“ 1”，最高有效位固定为值“ 0”。这两位之间的位不是固定的。根据所选的攻击类型，以下选项可见。哈希值提供组件试图为其找到有效原图像（或第二原图像）的哈希值。第二个原映像提供哈希值等于提供的哈希值的有效第二个原映像。纯文本为密钥恢复攻击提供纯文本。密文为密钥恢复攻击提供密文。 SAT Attack组件输出的解决方案是在对散列函数进行预映像或第二次预映像攻击的情况下为有效的预映像，或者在对对称密码进行密钥恢复攻击的情况下为对称密钥。由于翻译工具CBMC需要知道输入和输出变量，因此必须修改ANSI-C代码。因此，必须以特定方式标记输入和输出变量：输入和输出变量必须表示为“ INPUT_x”和“ OUTPUT_x”，其中索引“ x”为递增数字，以“ INPUT_0”和“ OUTPUT_0开头” ”作为最低有效输入或输出变量。变量的持续数量必须是无间隙的，并且每个变量必须在ANSI-C代码中实际使用。必须根据攻击类型以以下方式分配变量：前映像和第二个前映像攻击：INPUT_0-INPUT_n消息（前映像）OUTPUT_0-OUTPUT_k散列值密钥恢复攻击：INPUT_0-INPUT_n纯文本INPUT_n + 1-INPUT_m密钥OUTPUT_0- OUTPUT_k密文在密钥恢复攻击中，重要的是，密钥的最低有效变量的索引应在纯文本最高有效变量的索引之后立即开始（如果最高有效明文变量为“ INPUT_63”，则最低有效键变量必须为“ INPUT_64”）。如果变量符号错误，则组件可能输出错误的解决方案或返回错误。同样重要的是，ANSI-C代码中未分配任何输入变量，而所有输出变量均已分配。这意味着输入变量必须始终位于分配的右侧，而输出变量必须始终位于左侧（例如OUTPUT_0 = INPUT_0 ^ INPUT_1）。</usage><usage lang="ru">Компонент SAT Attack имеет один вход и три выходных разъема. Через входной разъем код ANSI-C может передаваться непосредственно компоненту при вставке в подключенный компонент ввода текста. Однако входной разъем не является обязательным, так как код ANSI-C также может быть напрямую передан компоненту, когда в настройках выбрана опция «Файл ввода» (см. Раздел «Параметры» ниже). Два выходных разъема «Выходной поток CBMC» и «Выходной поток разрешения SAT» каждый направляют вывод соответствующего процесса. Поскольку они отображают только информацию о состоянии этих двух процессов, выходы являются необязательными, и компонент будет работать, даже если они не подключены. Последний выходной разъем с именем «Выходной поток» является единственным обязательным коннектором. Он выводит информацию о состоянии компонента и, наконец, результат атаки, если он может быть найден. Компонент SAT Attack позволяет пользователю выбирать между несколькими типами атак и предлагает различные настройки, которые поясняются ниже. Некоторые параметры вводятся через текстовые поля. Строки, введенные в эти текстовые поля, могут быть либо шестнадцатеричными строками, обозначенными префикс «0x», либо двоичными строками, обозначенными префикс «0b». Тип атаки Выберите между атакой Preimage, атакой второго проема и атакой Key-recovery. Выбор входа Выберите, предоставляется ли код ANSI-C через компонент ввода текста, который подключен к входному разъему или напрямую через файл с локального устройства хранения. Имя основной функции Укажите имя функции, которая является точкой входа в коде ANSI-C, если это не функция с именем «main ()». Сохранить CNF в файле Предоставляет возможность сохранять созданный CNF в файле на локальном запоминающем устройстве. Только выход CNF. Проверьте этот параметр, если компонент должен остановить выполнение после того, как CNF будет сгенерирован, и выбранная атака будет закодирована в CNF. Это пропустит решение с помощью SAT-решения. Исправить входные биты Проверьте этот параметр на возможность исправить (т.е. указать значение в определенных битовых местоположениях) некоторые из входных битов. Когда отмечено, появится текстовое поле, в котором пользователь может ввести двоичную или шестнадцатеричную строку, чтобы заранее зафиксировать некоторые входные биты. Если бит или полубайт в строке не должен быть исправлен, это можно обозначить символом «*». Строка «0b0 *** 1», например, фиксирует младший значащий бит на значение «1», а самый старший бит - на значение «0». Биты между этими двумя битами не фиксированы. В зависимости от выбранного типа атаки видны следующие параметры. Значение хэша Укажите хеш-значение, для которого компонент пытается найти действительный прообраз (или второй прообраз). Второй прообраз Предоставьте действительный второй прообраз, хэш которого предоставлен хэш-значение. Plaintext Предоставление открытого текста для атаки восстановления ключей. Ciphertext Предоставляет зашифрованный текст для атаки восстановления ключей. Решение, которое выводится компонентом SAT Attack, является допустимым прообразом в случае прообраза или второй атаки preimage для хеш-функции или симметричного ключа в случае атаки восстановления ключа на симметричном шифра. Код ANSI-C должен быть изменен, поскольку переменные ввода и вывода должны быть известны инструменту перевода CBMC. Следовательно, входные и выходные переменные должны быть помечены определенным образом: входные и выходные переменные должны быть обозначены как «INPUT_x» и «OUTPUT_x», где индекс «x» является увеличивающимся числом, начиная с «INPUT_0» и «OUTPUT_0» «для наименее значимой входной или выходной переменной. Постоянное количество переменных должно быть бесщеточным, и каждая из переменных должна фактически использоваться в коде ANSI-C. Переменные должны быть назначены следующим образом в зависимости от типа атаки: Preimage и second preimage attack: INPUT_0 - INPUT_n Сообщение (Preimage) OUTPUT_0 - OUTPUT_k Значение хэширования Активация восстановления ключей: INPUT_0 - INPUT_n Plaintext INPUT_n + 1 - INPUT_m Key OUTPUT_0 - OUTPUT_k Ciphertext В атаке на восстановление ключа важно, чтобы индекс наименее значимой переменной ключа начинался сразу после индекса самой значимой переменной открытого текста (если наиболее значимой переменной открытого текста является «INPUT_63», наименьшая значимыми ключевыми переменными должны быть «INPUT_64»). Если переменные обозначения неисправны, компонент может выводить ложные решения или возвращать ошибку. Также важно, чтобы ни одна из входных переменных не была назначена в коде ANSI-C и что все выходные переменные назначены. Это означает, что входные переменные всегда должны находиться в правой части задания, а выходные переменные всегда должны быть слева (например, OUTPUT_0 = INPUT_0 ^ INPUT_1).</usage><usage lang="de-DE"><section headline="Input and Output">
      Die SAT-Attack-Komponente besitzt einen Eingabe-Konnektor und drei Ausgabe-Konnektoren. Durch den Eingabe-Konnektor kann der ANSI-C-Code direkt an die Komponente übergeben werden, indem dieser in einer angeschlossenen Texteingabe-Komponente eingefügt wird. Der Eingabe-Konnektor ist jedoch nur optional, da der ANSI-C-Code auch direkt an die Komponente übergeben werden kann, wenn in den Einstellungen die Option "Dateieingabe" gewählt wurde (siehe Abschnitt <i>Parameter</i> weiter unten). Die beiden Ausgabe-Konnektoren "CBMC Ausgabestrom" und "SAT-Solver-Ausgabestrom" leiten beide die Ausgabe des jeweiligen Prozesses weiter. Da diese lediglich Statusinformationen der beiden Prozesse ausgeben, sind beide Anschlüsse optional und müssen nicht verbunden sein, damit die Komponente laufen kann. Der letzte Ausgabe-Konnektor hat die Bezeichnung "Ausgabestrom" und ist der einzige Anschluss, der verbunden sein muss, damit die Komponente ausführbar ist. Durch den Ausgabestrom-Konnektor werden Statusinformationen über den Fortschritt der Komponente ausgegeben und schließlich das Ergebnis des Angriffs, sofern eine Lösung gefunden wurde.
    </section><section headline="Parameter">
      Die SAT-Attack-Komponente erlaubt dem Benutzer, zwischen verschiedenen Angriffs-Modi zu wählen. Sie bietet verschiedene Einstellungen, die im Folgenden erklärt werden. Einige der Parameter müssen über Textboxen eingegeben werden. Die Zeichenketten für diese Textboxen können entweder hexadezimale Zeichenketten sein, was mit dem Präfix "0x" gekennzeichnet wird, oder binäre Zeichenketten, was mit dem Präfix "0b" gekennzeichnet wird.
      <list><item><b>Angriffs-Modus</b> Wählen Sie zwischen First-Preimage-Angriff, Second-Preimage-Angriff und Key-Recovery-Angriff.
        </item><item><b>Eingabe-Auswahl</b> Wählen Sie aus, ob der ANSI-C-Code über die Texteingabe-Komponente, die mit dem Eingabe-Konnektor verbunden ist, zur Verfügung gestellt wird, oder direkt über eine Datei auf dem lokalen Speicher.
        </item><item><b>Name der main-Funktion</b> Geben Sie den Namen der Funktion ein, die der Einstiegspunkt des ANSI-C-Codes ist, falls dieser nicht "main()" lautet.
        </item><item><b>CNF in Datei speichern</b> Bietet die Möglichkeit, die generierte CNF in eine Datei auf dem lokalen Speicher zu schreiben.
        </item><item><b>Nur CNF-Ausgabe</b> Wählen Sie diese Option, wenn Sie wünschen, dass die Komponente die Ausführung stoppt, sobald die CNF generiert wurde und der gewählte Angriff in die CNF kodiert wurde. Diese Option überspringt den Aufruf des SAT-Solvers.
        </item><item><b>Eingabebits festlegen</b> Wählen Sie diese Option, um Eingabebits festzulegen. Wenn die Option angekreuzt ist, erscheint eine Textbox, in der Sie eine binäre oder hexadezimale Zeichenkette eingeben können, um einige Eingabebits im voraus festzulegen. Wenn ein Bit oder ein Nibble in der Zeichenkette nicht festgelegt werden soll, kann dafür das Zeichen '*' verwendet werden. Die Zeichenkette "0b0***1" beispielsweise legt das niederwertigste Bit auf den Wert '1' fest und das höchstwertigste Bit auf den Wert '0'. Die dazwischenliegenden Bits werden nicht festgelegt.
        </item></list>
      Die folgenden Optionen sind abhängig von dem gewählten Angriffs-Modus.
      <list><item><b>Hashwert</b> Geben Sie den Hashwert an, für den die Komponente versucht, ein gültiges Urbild oder (zweites Urbild) zu finden.
        </item><item><b>Zweites Urbild</b> Geben Sie ein gültiges zweites Urbild an, dessen Hashwert den angegebenen Hashwert ergibt.
        </item><item><b>Klartext</b> Geben Sie den Klartext für einen Key-Recovery-Angriff an.
        </item><item><b>Geheimtext</b> Geben Sie den Geheimtext für einen Key-Recovery-Angriff an.
        </item></list>

      Die ausgegebene Lösung der SAT-Attack-Komponente ist entweder ein gültiges Urbild im Falle eines First-Preimage-Angriffs oder eines Second-Preimage-Angriffs auf eine Hashfunktion, oder der Schlüssel im Falle eines Key-Recovery-Angriffs auf eine symmetrische Chiffre. Der ANSI-C-Code muss so angegeben werden, dass das Übersetzungstool CBMC weiß, welche Variablen die Eingabe und welche die Ausgabe darstellen. Dafür werden diese Variablen speziell gekennzeichnet: Eingabevariablen werden mit "INPUT_x" und Ausgabevariablen mit "OUTPUT_x" gekennzeichnet, wobei der Index 'x' eine fortlaufende Nummer darstellt, beginnend mit "INPUT_0" und "OUTPUT_0" für die niederwertigste Eingabe- und Ausgabevariable. Die fortlaufenden Zahlen müssen lückenlos sein und jede Variable muss im ANSI-C-Code tatsächlich verwendet werden.<newline /><newline />
      Die Variablen müssen abhängig vom Angriffs-Modus nach dem folgenden Schema zugewiesen werden:<newline /><newline /><b>First-Preimage- und Second-Preimage-Angriff:</b><list><item><b>INPUT_0 - INPUT_n</b> Nachricht (Urbild)
        </item><item><b>OUTPUT_0 - OUTPUT_k</b> Hashwert
        </item></list><b>Key-Recovery-Attack:</b><list><item><b>INPUT_0 - INPUT_n</b> Klartext
        </item><item><b>INPUT_n+1 - INPUT_m</b> Schlüssel
        </item><item><b>OUTPUT_0 - OUTPUT_k</b> Geheimtext
        </item></list>
      Bei einem Key-Recovery-Angriff ist es wichtig, dass der Index der niederwertigsten Variable des Schlüssels direkt nach dem Index der höchstwertigsten Variable des Klartextes beginnt (wenn die höchstwertigste Variable des Klartextes "INPUT_63" ist, muss die niederwertigste Variable des Schlüssel "INPUT_64" sein). Wenn die Variablenbelegungen fehlerhaft sind, kann es sein, dass die Komponente falsche Lösungen ausgibt oder zu einem Fehler führt. Weiterhin ist es wichtig, dass keine der Eingabevariablen im ANSI-C-Code zugewiesen wird, und dass jede Ausgabevariablen zugewiesen sind. Das heißt, dass die Eingabevariablen immer auf der rechten Seite einer Zuweisung stehen müssen, und die Ausgabevariablen immer auf der linken Seite (z.B. OUTPUT_0 = INPUT_0 ^ INPUT_1).
    </section></usage><presentation lang="en"></presentation><presentation lang="de-DE"></presentation><references><linkReference id="xl0"><link url="http://www.cryptosystem.net/aes/tools.html" lang="en" /><caption lang="en">Tools for Experimental Algebraic Cryptanalysis</caption><link url="http://www.cryptosystem.net/aes/tools.html" lang="de-DE" /><caption lang="de-DE">Tools für experimentelle algebraische Kryptoanalyse</caption></linkReference></references></documentation>