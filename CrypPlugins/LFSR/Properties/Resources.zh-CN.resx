<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PluginCaption" xml:space="preserve">
    <value>LFSR</value>
  </data>
  <data name="PluginTooltip" xml:space="preserve">
    <value>线性反馈移位寄存器</value>
  </data>
  <data name="InputTapSequenceCaption" xml:space="preserve">
    <value>TapSequence</value>
  </data>
  <data name="InputTapSequenceTooltip" xml:space="preserve">
    <value>包含抽头的字符串，作为c_i的序列或多项式（例如：1011，它等于字符串x ^ 4 + x ^ 2 + x +1。请注意，最后一个1是x ^ 0 ，在插件中隐式设置为1）。</value>
  </data>
  <data name="InputSeedCaption" xml:space="preserve">
    <value>种子</value>
  </data>
  <data name="InputSeedTooltip" xml:space="preserve">
    <value>所有状态的初始二进制值（例如：1001）。</value>
  </data>
  <data name="InputClockBoolCaption" xml:space="preserve">
    <value>时钟</value>
  </data>
  <data name="InputClockBoolTooltip" xml:space="preserve">
    <value>可选的外部时钟信号（通过CLK插件）。</value>
  </data>
  <data name="OutputStringCaption" xml:space="preserve">
    <value>字符串输出</value>
  </data>
  <data name="OutputStringTooltip" xml:space="preserve">
    <value>包含具有舍入长度的输出流的字符串（例如：1001001，假设已经执行了7个舍入）。</value>
  </data>
  <data name="OutputBoolCaption" xml:space="preserve">
    <value>布尔输出</value>
  </data>
  <data name="OutputBoolTooltip" xml:space="preserve">
    <value>包含当前输出位作为布尔值。</value>
  </data>
  <data name="OutputClockingBitCaption" xml:space="preserve">
    <value>附加输出位</value>
  </data>
  <data name="OutputClockingBitTooltip" xml:space="preserve">
    <value>将LFSR的特定阶段输出为布尔值。</value>
  </data>
  <data name="OutputBoolArrayCaption" xml:space="preserve">
    <value>阶段的布尔数组输出</value>
  </data>
  <data name="OutputBoolArrayTooltip" xml:space="preserve">
    <value>输出LFSR的所有阶段。</value>
  </data>
  <data name="AlwaysCreateOutputCaption" xml:space="preserve">
    <value>始终创建输出</value>
  </data>
  <data name="AlwaysCreateOutputTooltip" xml:space="preserve">
    <value>启用此复选框后，即使时钟设置为false，也会生成输出。输出位将是最后一个时钟周期的位。</value>
  </data>
  <data name="ClockingBitCaption" xml:space="preserve">
    <value>附加输出位＃</value>
  </data>
  <data name="ClockingBitTooltip" xml:space="preserve">
    <value>哪一位应作为附加输出生成？例如作为时钟位。</value>
  </data>
  <data name="NoQuickwatchCaption" xml:space="preserve">
    <value>不显示简报</value>
  </data>
  <data name="NoQuickwatchTooltip" xml:space="preserve">
    <value>启用此复选框后，将不会显示任何演示文稿，并且性能会更好。</value>
  </data>
  <data name="OutputStagesCaption" xml:space="preserve">
    <value>输出阶段</value>
  </data>
  <data name="OutputStagesTooltip" xml:space="preserve">
    <value>启用此复选框后，将输出当前状态。</value>
  </data>
  <data name="PeriodCaption" xml:space="preserve">
    <value>LFSR的时期：</value>
  </data>
  <data name="PeriodTooltip" xml:space="preserve">
    <value>根据反馈多项式和种子指示周期。</value>
  </data>
  <data name="PolynomialCaption" xml:space="preserve">
    <value>反馈多项式</value>
  </data>
  <data name="PolynomialTooltip" xml:space="preserve">
    <value>以文本或数字方式定义反馈多项式。例如，x ^ 5 + x ^ 2 +1等于10010。</value>
  </data>
  <data name="RoundsCaption" xml:space="preserve">
    <value>回合</value>
  </data>
  <data name="RoundsTooltip" xml:space="preserve">
    <value>应生成多少位？注意：仅在不使用外部时钟的情况下才适用。</value>
  </data>
  <data name="SaveCurrentStateCaption" xml:space="preserve">
    <value>保存LFSR的状态</value>
  </data>
  <data name="SaveCurrentStateTooltip" xml:space="preserve">
    <value>停止并重新启动插件或保存工作空间时，保存当前状态。</value>
  </data>
  <data name="SeedCaption" xml:space="preserve">
    <value>种子</value>
  </data>
  <data name="SeedTooltip" xml:space="preserve">
    <value>定义LFSR的种子（初始状态）。例如11100。</value>
  </data>
  <data name="UseAdditionalOutputBitCaption" xml:space="preserve">
    <value>生成添加。输出位</value>
  </data>
  <data name="UseAdditionalOutputBitTooltip" xml:space="preserve">
    <value>启用此复选框后，将生成附加输出位。</value>
  </data>
  <data name="UseBoolClockCaption" xml:space="preserve">
    <value>使用外部时钟</value>
  </data>
  <data name="UseBoolClockTooltip" xml:space="preserve">
    <value>启用此复选框后，将使用外部时钟。</value>
  </data>
  <data name="UseBoolClockTPCaption" xml:space="preserve">
    <value>使用外部时钟</value>
  </data>
  <data name="UseBoolClockTPTooltip" xml:space="preserve">
    <value>启用此复选框后，将使用外部时钟（例如CLK组件）。</value>
  </data>
  <data name="initLFSRCaption" xml:space="preserve">
    <value>抽奖</value>
  </data>
  <data name="initLFSRTooltip" xml:space="preserve">
    <value>如果多项式适合种子，则绘制LFSR。</value>
  </data>
  <data name="No_Quickwatch_data_right_now_" xml:space="preserve">
    <value>现在没有数据可显示。</value>
  </data>
  <data name="AlwaysCreateOutputList1" xml:space="preserve">
    <value>总是产生输出？</value>
  </data>
  <data name="ClockGroup" xml:space="preserve">
    <value>时钟属性</value>
  </data>
  <data name="ClockingBitGroup" xml:space="preserve">
    <value>附加输出位</value>
  </data>
  <data name="Feedback_polynomial" xml:space="preserve">
    <value>反馈多项式</value>
  </data>
  <data name="NoQuickwatchList1" xml:space="preserve">
    <value>显示演示文稿？</value>
  </data>
  <data name="Period_of_LFSR" xml:space="preserve">
    <value>LFSR的时期</value>
  </data>
  <data name="SaveCurrentStateList1" xml:space="preserve">
    <value>保存当前状态？</value>
  </data>
  <data name="UseAdditionalOutputBitList1" xml:space="preserve">
    <value>产生额外的输出位？</value>
  </data>
  <data name="UseBoolClockList1" xml:space="preserve">
    <value>使用外部时钟？</value>
  </data>
  <data name="MaxRecordedRoundsCaption" xml:space="preserve">
    <value>最高记录中间结果</value>
  </data>
  <data name="MaxRecordedRoundsTooltip" xml:space="preserve">
    <value>要保留在内存中的最大中间状态（移位）数</value>
  </data>
  <data name="PresentationShiftCaption" xml:space="preserve">
    <value>倒退演示中的回合数</value>
  </data>
  <data name="PresentationShiftTooltip" xml:space="preserve">
    <value>演示文稿显示了当前一轮落后许多回合的回合</value>
  </data>
  <data name="RoundNumber" xml:space="preserve">
    <value>回合：</value>
  </data>
  <data name="SeedFlippedCaption" xml:space="preserve">
    <value>种子：左位在先</value>
  </data>
  <data name="SeedFlippedTooltip" xml:space="preserve">
    <value>种子首先从最左位开始移入寄存器（与输入相比，种子以翻转的顺序出现在寄存器中）</value>
  </data>
</root>