<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="inputKeyDescription" xml:space="preserve">
    <value>Input of the key used for the encryption</value>
  </data>
  <data name="inputKeyName" xml:space="preserve">
    <value>Key input</value>
  </data>
  <data name="inputTextDescription" xml:space="preserve">
    <value>Input of the text that is to be encrypted</value>
  </data>
  <data name="inputTextName" xml:space="preserve">
    <value>Text input</value>
  </data>
  <data name="KeysizeCaption" xml:space="preserve">
    <value>Keysize</value>
  </data>
  <data name="KeysizeTooltip" xml:space="preserve">
    <value>Select the size of the key.</value>
  </data>
  <data name="OutputStreamCaption" xml:space="preserve">
    <value>Text output</value>
  </data>
  <data name="OutputStreamTooltip" xml:space="preserve">
    <value>Output of the ciphertext</value>
  </data>
  <data name="PluginCaption" xml:space="preserve">
    <value>AES Visualization</value>
  </data>
  <data name="PluginTooltip" xml:space="preserve">
    <value>Visualization of AES encryption</value>
  </data>
  <data name="addKeyButton" xml:space="preserve">
    <value>Add Key</value>
  </data>
  <data name="addKeyExplanation" xml:space="preserve">
    <value>The round key is added to the current state by XORing the bytes.</value>
  </data>
  <data name="autoButton" xml:space="preserve">
    <value>Auto</value>
  </data>
  <data name="encButton" xml:space="preserve">
    <value>Skip Expansion</value>
  </data>
  <data name="encryptionIntro" xml:space="preserve">
    <value>3</value>
  </data>
  <data name="encryptionIntro1" xml:space="preserve">
    <value>Encryption</value>
  </data>
  <data name="encTextBlock" xml:space="preserve">
    <value>Encryption</value>
  </data>
  <data name="endButton" xml:space="preserve">
    <value>End</value>
  </data>
  <data name="expansionExplanation" xml:space="preserve">
    <value>First, the last four bytes of the previous key are taken. Afterwards, the last byte is placed at the front.</value>
  </data>
  <data name="expansionExplanation1" xml:space="preserve">
    <value>Every byte in the state matrix is exchanged with the corresponding byte from the S-box.</value>
  </data>
  <data name="expansionExplanation2" xml:space="preserve">
    <value>A round constant is added.</value>
  </data>
  <data name="expansionExplanation3" xml:space="preserve">
    <value>Adding the first four bytes of the previous key gives you the first four bytes of the next key.</value>
  </data>
  <data name="expansionExplanation4" xml:space="preserve">
    <value>For column x of the new key you XOR column x from the previous key with column x-1 from the new key.</value>
  </data>
  <data name="expansionIntro" xml:space="preserve">
    <value>2</value>
  </data>
  <data name="expansionIntro1" xml:space="preserve">
    <value>Key Expansion</value>
  </data>
  <data name="expButton" xml:space="preserve">
    <value>To Expansion</value>
  </data>
  <data name="expTextBlock" xml:space="preserve">
    <value>Expansion</value>
  </data>
  <data name="initialRoundTextBlock" xml:space="preserve">
    <value>Initial Round</value>
  </data>
  <data name="introduction" xml:space="preserve">
    <value>Advanced Encryption Standard</value>
  </data>
  <data name="introduction1" xml:space="preserve">
    <value>(AES)</value>
  </data>
  <data name="introduction2" xml:space="preserve">
    <value>Visualization of this modern block cipher</value>
  </data>
  <data name="mixColButton" xml:space="preserve">
    <value>Mix Col.</value>
  </data>
  <data name="mixColExplanation" xml:space="preserve">
    <value>One column is taken from the current state and placed next to the multiplication matrix.</value>
  </data>
  <data name="mixColExplanation1" xml:space="preserve">
    <value>Then it is multiplied with the multiplication matrix to determine the next column of the next state.</value>
  </data>
  <data name="playButton" xml:space="preserve">
    <value>Next</value>
  </data>
  <data name="prevOperationButton" xml:space="preserve">
    <value>Prev. Operation</value>
  </data>
  <data name="prevRoundButton" xml:space="preserve">
    <value>Prev. Round</value>
  </data>
  <data name="Round1" xml:space="preserve">
    <value>Round 1</value>
  </data>
  <data name="Round10" xml:space="preserve">
    <value>Round 10</value>
  </data>
  <data name="Round11" xml:space="preserve">
    <value>Round 11</value>
  </data>
  <data name="Round12" xml:space="preserve">
    <value>Round 12</value>
  </data>
  <data name="Round13" xml:space="preserve">
    <value>Round13</value>
  </data>
  <data name="Round14" xml:space="preserve">
    <value>Round14</value>
  </data>
  <data name="Round2" xml:space="preserve">
    <value>Round 2</value>
  </data>
  <data name="Round3" xml:space="preserve">
    <value>Round 3</value>
  </data>
  <data name="Round4" xml:space="preserve">
    <value>Round 4</value>
  </data>
  <data name="Round5" xml:space="preserve">
    <value>Round 5</value>
  </data>
  <data name="Round6" xml:space="preserve">
    <value>Round 6</value>
  </data>
  <data name="Round7" xml:space="preserve">
    <value>Round 7</value>
  </data>
  <data name="Round8" xml:space="preserve">
    <value>Round 8</value>
  </data>
  <data name="Round9" xml:space="preserve">
    <value>Round 9</value>
  </data>
  <data name="shiftLeftButton" xml:space="preserve">
    <value>&lt;&lt;</value>
  </data>
  <data name="shiftRightButton" xml:space="preserve">
    <value>&gt;&gt;</value>
  </data>
  <data name="shiftRowButton" xml:space="preserve">
    <value>Shift Row</value>
  </data>
  <data name="shiftRowExplanation" xml:space="preserve">
    <value>First, the second row is shifted once to the left. Then, the third row is shifted twice towards the left, and finally the forth row is shifted three times to the left. The overlapping bytes are transferred to the right to form a 4 x 4 matrix.</value>
  </data>
  <data name="skipOperationButton" xml:space="preserve">
    <value>Skip Operation </value>
  </data>
  <data name="skipRoundButton" xml:space="preserve">
    <value>Skip Round</value>
  </data>
  <data name="startButton" xml:space="preserve">
    <value>Start</value>
  </data>
  <data name="subBytesButton" xml:space="preserve">
    <value>Sub Bytes</value>
  </data>
  <data name="subBytesExplanation" xml:space="preserve">
    <value>First, a byte is transferred from the state matrix to the transition spot and split up.</value>
  </data>
  <data name="subBytesExplanation1" xml:space="preserve">
    <value>The corresponding byte in the S-box is determined and placed into the result matrix.</value>
  </data>
  <data name="resultTextBlock" xml:space="preserve">
    <value>Result</value>
  </data>
  <data name="introTextBlock" xml:space="preserve">
    <value>AES is a modern block cipher.  AES takes two inputs: 
the plaintext that is to be encrypted and a key.  After the encryption AES outputs the ciphertext.</value>
  </data>
  <data name="introTextBlock1" xml:space="preserve">
    <value>AES starts with the "Key Expansion" in which round keys are derived from the original key. 

After the expansion an initial round takes place, in which the original key is applied to the plaintext. 

Depending on the key length the algorithm will go through 9, 11, or 13 rounds. Each round consists of the four operations: "SubBytes", "ShiftRow", "MixColumns", and "AddRoundKey". 

Once these rounds are completed one last round is performed, which has no "MixColumn" step.</value>
  </data>
  <data name="Back" xml:space="preserve">
    <value>Back</value>
  </data>
  <data name="intro" xml:space="preserve">
    <value>1</value>
  </data>
  <data name="intro1" xml:space="preserve">
    <value>Intro</value>
  </data>
  <data name="IntroText" xml:space="preserve">
    <value>Intro</value>
  </data>
  <data name="Ciphertext" xml:space="preserve">
    <value>Ciphertext</value>
  </data>
  <data name="KeyText" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="Plaintext" xml:space="preserve">
    <value>Plaintext</value>
  </data>
</root>